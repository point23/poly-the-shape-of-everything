#+begin_src plantuml :file Game_Input_Module.png
title Game Input Module

class Button_State {
    button: Game_Button
    ended_down: boolean
    counter: number
    pressed_at: number
}

class Game_Input {
    buffered_player_actions: Queue<Game_Button>
    pending_records: Button_State[]
    button_states: Map<number, button_state>
    press(b: Game_Button)
    reset()
    increase_count(b: Game_Button)
    release(b: Game_Button)
}

class Game_Input_Handler {
    input: Game_Input
    init(i: Game_Input)
    clear()
    update_input()
    name(): string
}

class Virtual_Controller extends Game_Input_Handler 
class Keyboard extends Game_Input_Handler

enum Game_Button
enum Dpad_Button
enum Action_Button
enum Keyboard_Command_Button

Virtual_Controller --> Game_Button
Virtual_Controller --> Dpad_Button
Virtual_Controller --> Action_Button

Keyboard --> Game_Button
Keyboard --> Keyboard_Command_Button

Game_Input_Handler o-> Game_Input

Game_Input --> Button_State
Game_Input --> Game_Button
#+end_src

#+begin_src plantuml :file Level_Editor.png

title Puzzle Game Level Editor

abstract Game_Mode_Base <<State>> {
    on_enter()
    on_exit()
    save_level()
    handle_key_down(event: EventKeyboard)
    handle_key_up(event: EventKeyboard)
    handle_mouse_down(event: EventMouse)
    handle_mouse_move(event: EventMouse)
    handle_mouse_scroll(event: EventMouse)
    handle_touch_start(event: EventTouch)
    handle_touch_move(event: EventTouch)
    handle_touch_end(event: EventTouch)
}

class Contextual_Manager <<Context>> {
  {static} instance: Contextual_Manager
  game_modes: Game_Mode[]
  current_mode: Game_Mode
  current_mode_idx: number
  register_events();
  unregister_events();
  switch_mode();
  save_level();
  {static} Settle(i: Contextual_Manager);
}

class Entity_Edit_Mode <<ConcreteStateA>> {
  camera: Camera
  copy_selected_entities()
  paste_copied_entities()
  delete_selected_entities()
  select()
  deselect()
  select_all()
  deselect_all()
  move_selected_entities()
  rotate_selected_entities()
}

class Test_Run_Mode <<ConcreteStateB>> {
  inputs_navigatar: Navigatar
  input_manager: Input_Manager 
  show_hints()
  init_ui()
  clear_ui()
}

class Swipe_Camera_Mode <<ConcreteStateC>> {
  controller: Camera_3D_Controller;
}

class Light_Mode <<ConcreteStateD>> {
  controller: Camera_3D_Controller;
}

Entity_Edit_Mode --|> Game_Mode_Base
Test_Run_Mode --|> Game_Mode_Base
Swipe_Camera_Mode --|> Game_Mode_Base
Light_Mode --|> Game_Mode_Base

Contextual_Manager o--> Game_Mode_Base

class Level_Editor <<Client>> {}
Level_Editor --> Contextual_Manager

#+end_src

#+begin_src plantuml :file  Game_Entity_Module.png
title Puzzle Game Entity Module
enum Entity_Type
enum Polyomino_Type
enum Direction
enum Quadrant

class Tree_Node {
  x: number
  y: numebr
  values: Game_Entity[]
  children: [Tree_Node, Tree_Node, Tree_Node, Tree_Node, Tree_Node]
}

class Proximity_Grid {
  origin: Vec3
  grid_size: Size
  quad_tree: Tree_Node
  move_entity(e: Game_Entity, p: Vec3)
  add_entity(e: Game_Entity)
  remove_entity(e: Game_Entity)
  point_search(p: Vec3): Game_Entity[]
  local2world(local_pos: Vec3): Vec3
}

class Serializable_Entity_Data {
  prefab: string
  position: Vec3
  rotation: Direction
}

class Undoable_Entity_Data {
  {static} default: Undoable_Entity_Data
  memory: Int32Array
}

class Game_Entity {
  id: number
  undobale: Undoable_Entity_Data
  polyomino_type: Polyomino_Type
  entity_type: Entity_Type
  editing_cover: MeshRenderer
  body: Polygon_Entity
  indicator: Polygon_Entity
}

class Entity_Manager {
  all_entities: Game_Entity[]
  proximity_grid: Proximity_Grid
  undo_handler: Undo_Handler
  load_entities(entities_info: any)
  load_entity(info: any, id: number = null): Game_Entity
  find(id: number)
  reclaim(e: Game_Entity)
  locate_entities(p: Vec3): Game_Entity[]
  locate_supporters(p: Vec3, depth: number = 1): Game_Entity[]
  locate_supportees(p: Vec3)
  locate_current_supporters(e: Game_Entity): Game_Entity[]
  locate_future_supporters(e: Game_Entity, d: Direction): Game_Entity[]
  locate_current_supportees(e: Game_Entity): Game_Entity[]
}

Proximity_Grid --> Tree_Node
Tree_Node --> Quadrant
Proximity_Grid <--o Entity_Manager

Entity_Manager o--> Undo_Handler
Entity_Manager o- Game_Entity: all_entities >

Game_Entity o--> Undoable_Entity_Data
Game_Entity --> Serializable_Entity_Data
Game_Entity --> Entity_Type
Game_Entity --> Direction
Game_Entity --> Polyomino_Type

#+end_src

#+begin_src plantuml :file  Game_Movement_Module.png
title Puzzle Game Movement Module

class Transaction_Manager {
  control_flags: number
  issued_transactions: Move_Transaction[]
  clear()
  new_transaction(move: Single_Move, duration: number): boolean
  update_transactions(): void
}

class Move_Transaction {
  id: number
  moves: Map<number, Single_Move>
  arcs: Map<number, Singe_Move[]>
  entity_manager: Entity_Manager
  piority: number
  issue_time: Gameplay_Time
  commit_time: Gameplay_Time
  sorted_moves(): Single_Move[]
  add_move(move: Single_Move): void
  add_arc(move: Single_Move): void
  debug_info(): string
}
Transaction_Manager o--> Move_Transaction : issued_transactions
Move_Transaction --> Entity_Manager

together {
abstract class Single_Move {
  id: number
  info: Move_Info
  flags: number
  piority: number
  execute_in_preorder(transaction: Move_Transaction)
  complete_in_postorder(transaction: Move_Transaction)
  enact(transaction: Move_Transaction): boolean
  execute(transaction: Move_Transaction)
  complete(transaction: Move_Transaction)
  update(transaction: Move_Transaction, ratio: number)  
  debug_info(): string
}

class Move_Info {
  move_type: Move_Type;
  source_entity_id: number
  target_entity_id: number
  start_position: Vec3
  end_position: Vec3
  start_direction: Direction
  end_direction: Direction
  reaction_direction: Direction
}

enum Move_Type
enum Move_Flags
enum Move_Priorities
}

Single_Move o--> Move_Info
Single_Move --> Move_Flags
Single_Move --> Move_Priorities
Move_Info --> Move_Type

Move_Transaction o--> Single_Move : moves


#+end_src

#+begin_src plantuml :file  Gameplay_Time.png
title Puzzle Gameplay Timer

class Gameplay_Time {
  round: number
  tick: number
}

class Gameplay_Timer {
  tick_idx: number
  round_idx: number
  running_idx: number

  reset(): void
  now(): number
  compare(a: Gameplay_Time, b: Gameplay_Time): number
  set_gameplay_time(t: Gameplay_Time)
  get_gameplay_time(): Gameplay_Time
  run(caller: Component, loop_callback: (()=>{}), tick_callbacks: (()=>{})[])
  stop()  
}

Gameplay_Timer --> Gameplay_Time

#+end_src

#+begin_src plantuml :file  Game_Recorder.png
title Puzzle Game Recorder

class Input_Record {
  button: Game_Button
  time: Gameplay_Time
}

class Game_Input_Recorder {
  records: Input_Record[]  
  add(button: Game_Button, time: Gameplay_Time): void
  cosume(): {succeed: boolean, button: Game_Button}
  completed(): boolean
}

Game_Input_Recorder o--> Input_Record : moves
#+end_src
